{"entries":[{"title":null,"baseurl":"","url":"/404.html","date":null,"categories":[],"body":""},{"title":null,"baseurl":"","url":"/project/index.html","date":null,"categories":[],"body":" Project | Zhou Ao Zhou Ao' Project Search AI for 2048 Game AI with Reliable Algorithms to win 2048 Game 2014-11-21 Search Financial Application Database System (FADS) for Living Sanctuary Brethren Church Database Management System Designed for Living Sanctuary Brethren Church 2014-10-23 Search Numerical Simulation of Plasma Turbulence in Edge Region with Magnetic Bound The project simulates the nonlinear plasma turbulent transport in edge region. In the physical model, the impact of ion temperature on the potential of plasma is considered to precisely simulate the nonlinear development and spacial structure of plasma potential. 2014-04-01 Blog Project Me About © 2014 Zhou Ao. All contents under (CC) BY-NC-SA license , unless otherwise noted. MathJax.Hub.Config({ tex2jax: {inlineMath: [['$','$'], ['\\\\(','\\\\)']]} }); (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){ (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o), m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m) })(window,document,'script','//www.google-analytics.com/analytics.js','ga'); ga('create', 'UA-57134466-1', 'auto'); ga('require', 'displayfeatures'); ga('send', 'pageview'); // ga(‘set’, ‘&uid’, ); // use user_id logged in to set up ID。 "},{"title":null,"baseurl":"","url":"/index.html","date":null,"categories":[],"body":" Zhou Ao Zhou Ao Developer  •  Physics Undergraduate Blog Project Me About © 2014 Zhou Ao. All contents under (CC) BY-NC-SA license , unless otherwise noted. MathJax.Hub.Config({ tex2jax: {inlineMath: [['$','$'], ['\\\\(','\\\\)']]} }); (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){ (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o), m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m) })(window,document,'script','//www.google-analytics.com/analytics.js','ga'); ga('create', 'UA-57134466-1', 'auto'); ga('require', 'displayfeatures'); ga('send', 'pageview'); // ga(‘set’, ‘&uid’, ); // use user_id logged in to set up ID。 "},{"title":null,"baseurl":"","url":"/search/index.html","date":null,"categories":[],"body":" Search | Zhou Ao Zhou Ao | Search Search Zhou Ao's Blog Search results {{#entries}} <article> <h3> {{#date}}<small><time datetime=\"{{pubdate}}\" pubdate>{{displaydate}}</time></small>{{/date}} <a href=\"{{url}}\">{{title}}</a> </h3> </article> {{/entries}} Blog Project Me About © 2014 Zhou Ao. All contents under (CC) BY-NC-SA license , unless otherwise noted. MathJax.Hub.Config({ tex2jax: {inlineMath: [['$','$'], ['\\\\(','\\\\)']]} }); (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){ (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o), m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m) })(window,document,'script','//www.google-analytics.com/analytics.js','ga'); ga('create', 'UA-57134466-1', 'auto'); ga('require', 'displayfeatures'); ga('send', 'pageview'); // ga(‘set’, ‘&uid’, ); // use user_id logged in to set up ID。 $(function() { $('#search-query').lunrSearch({ indexUrl: '/search.json', // URL of the `search.json` index data for your site results: '#search-results', // jQuery selector for the search results container entries: '.entries', // jQuery selector for the element to contain the results list, must be a child of the results element above. template: '#search-results-template' // jQuery selector for the Mustache.js template }); }); "},{"title":null,"baseurl":"","url":"/blog/index.html","date":null,"categories":[],"body":" Blog | Zhou Ao Zhou Ao's Blog Search Integration of Mergesort and Insertion Sort Mergesort is faster than insertion sort, while whens the size of sub-arrays are small, the overhead of many recursive calls makes the algorithm inefficient. Integration of mergesort and insertion sort is a good way to develop advanced sort algorithm. 2014-11-28 Search Binary Search Time Complexity: Average Number of Comparisons Introduce binary search, and calculate the average number of comparisons in the algorithm. 2014-11-25 Search Hacker on the Way My first blog to the world. 2014-11-22 Blog Project Me About © 2014 Zhou Ao. All contents under (CC) BY-NC-SA license , unless otherwise noted. MathJax.Hub.Config({ tex2jax: {inlineMath: [['$','$'], ['\\\\(','\\\\)']]} }); (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){ (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o), m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m) })(window,document,'script','//www.google-analytics.com/analytics.js','ga'); ga('create', 'UA-57134466-1', 'auto'); ga('require', 'displayfeatures'); ga('send', 'pageview'); // ga(‘set’, ‘&uid’, ); // use user_id logged in to set up ID。 "},{"title":"About My Website","baseurl":"","url":"/about/index.html","date":null,"categories":[],"body":" I design and develop this site using , following these two styleguides, Aerial and Strate . Hosted by . Full-text search is supported by jekyll-lunr-js-search . Source available on github . Unless specified otherwise, contents on this site is licensed under the Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License . "},{"title":"Zhou Ao","baseurl":"","url":"/me/index.html","date":null,"categories":[],"body":"Hi, I am Zhou Ao , from Peking University . Great pleasure to see you on my blog site. Now I am a junior majoring in Physics , which I believe, is the logic of the world. But disappointingly, Physics, the art of objects, cares nothing about humanity. So I doubled Economics at year two. Economics reveals the interesting action of human beings both in micro scope and macro scope. However, I never believe that the behavior of people can be modeled with economic theories. As for why I am interested in computer science , the answer is that I am the generation of Internet, which is built by hackers and programmers. I hold the belief that only technology is able to improve the world, although science is the basis of technology. One day, I dream to apply my Physics thinking to computer engineering and then to make the life of human a little bit easier and more interesting. "},{"title":"Numerical Simulation of Plasma Turbulence in Edge Region with Magnetic Bound","baseurl":"","url":"/project/Plasma.html","date":"2014-04-01 00:00:00 +0800","categories":["project"],"body":"The project is conducted with the cooperation with Zhang Huaxiang and me under the guidance of Professor Li Bo . For details, you can refer to Project Proposal . "},{"title":"Financial Application Database System (FADS) for Living Sanctuary Brethren Church","baseurl":"","url":"/project/FADS.html","date":"2014-10-23 00:00:00 +0800","categories":["project"],"body":"The FADS was designed to be a web-based solution that could allow Bethesda CARE to search, manage and edit the records of FA Applicants and Recipients. Additionally, the system had to enable administrators to manage user entities and permissions, and to generate reports on disbursement data. In order to design the database that fulfilled business functionality while minimizing data redundancies, a slew of design methods were adopted. The team began with a Data Flow Diagram of the business process, followed by developing Use Case Narratives with Cross-Functional Flow Charts for the system. These use cases were checked and affirmed by the client representative periodically as well. Data relationships were established by designing an Enhanced ERD Model . Data redundancies were eliminated by normalization through a Relational Model . The team additionally created a **Data Dictionary **to standardize data representations. The finalized client product was developed using PHP and MySQL , and deployed via Wampserver. It is Windows compatible and accessible only through Bethesda CARE’s intranet server. Capacity requirements were minimal, under 100MB of storage required. For details, You can visit the Github repository . "},{"title":"AI for 2048 Game","baseurl":"","url":"/project/2048%20AI.html","date":"2014-11-21 00:00:00 +0800","categories":["project"],"body":"2048 is a popular strategy game on multiple platforms. It developed by Gabriele Cirulli , a Italian young talent, which was built using HTML, CSS and JavaScript and was released as open-source software on Github. The AI for 2048 game is designed to win the game with high probability. Now the project is still in progress. Warm welcome to contribute to the project together. For details, you can visit the Github repository . "},{"title":"Hacker on the Way","baseurl":"","url":"/blog/Hacker%20on%20the%20Way.html","date":"2014-11-22 00:00:00 +0800","categories":["blog"],"body":"Words in the Beginning Finally, I am writing in my own blog. During past couple of days, a newbie, I, who only knew little about the World Wide Web, started to create interesting things based on the web out of curiosity. The feeling of building things is cool, especially something meaningful. I hope from now on, I can learn to become a hacker, devoting myself to solving problems with powerful computational tools, and make the world little bit prettier. Things have done these days 1. Financial Assistance Database System for Living Sanctuary Brethren Church The Financial Assistance Database System (FADS) is a database management software for the course BC2402 Database Management & Business Intelligence . In fact, I did not take this course, while my girlfriend did. Although she majors in computer science and business, programming never eased her. In urgent request of my girlfriend to help her with the project, I had to survive myself from server-side programming, client-side programming and SQL with my not so sufficient knowledge of C/C++ and Matlab. For only one week , I learned HTML , CSS , PHP and MySQL . Isn't it amazing? What really drove me crazy was to install Apache/PHP/MySQL on my own laptop with Windows 8.1. Without a installation wizard, there were huge works to do with the configuration files with considerable variables inside and to type every command in CMD. Here, I would like to share some useful sites which I used for the FADS project. Programming Notes This a substantial note written by Associate Professor Chua Hock Chuan , including How-To, Java , SQL, Server-Side, Client-Side, JavaME, Game, OpenGL, C++ and Android. It is a rarely brief but excellent note for new programmers. W3Schools Perhaps, this is the world' largest web development site. There are professional tutorials and references for HTML/CSS, JavaScript, Server Side, XML and Web Building with plenty of vivid instant examples. You can find everything you need to build a website. Apache/PHP/MySQL For the installation, I searched oceans of documentations, articles, blogs and posts, but failed to find one page that could give step-by-step instructions from the beginning to end. I am able to make it only with references from different source. Maybe when I become a real master one day, I will write a blog about the installation. With the joint effort with Gibson Cheong , we used HTML and CSS to build the front-end interface, and as for the back-end, we used PHP and MySQL . The FADS is a multi-user management system. There are three types of users: super user, administrator and system user, and two kinds of operations, user related operation and financial application (FA) related operation. User related operations include create user, view user, edit user, delete user. Financial application related operation include create FA, search FA, view FA, edit FA, delete FA, generate report, issue disbursement. Different users with different user types have corresponding authorities. Super users have authority to do all the operations. Administrators have authority to do all the financial application related operations. And system users only have authority to create FA and view FA. As for implementation, I did the part of user management and interface design , and Gibson did part of the financial management and compilation. Actually, this is my first time to get involved such a project. To be honest, I was quite enjoying it. There is no doubt I gained practical skills throng the project. 2. Registration of My Own Domain After the last Financial Assistance Database System Project and knowing how to create web page using HTML and CSS, I could not wait to publish something real on the Internet. By researching, I realized that to do this, I had to do the following two steps. Register a domain . Find a host service provider . Setup the web host and upload web pages . For the domain, I desired to register a top level domain related my name, Zhou Ao, but I did not expect to spend on any money on it (How poor a undergraduate student is). So I chose to register a .tk domain in Freenom . The free web host may never be a good choice, only if you just want to try publish something unimportant. For a real site, the accessibility of free web host is far from the stander. However, just for a trail, I decided to use the service of 00webhost . Then, I tried to post some very simple pages to the web server and succeeded to visit my pages throng the Internet. It is extremely exciting! 3. Git and Github Github appeared in my eyesight as I started to be addicted to the popular game 2048. 2048 is a strategy web game developed by Gabriele Cirulli , a Italian young talent, which was built using HTML, CSS and JavaScript and was released as open-source software on Github . Every soon, the game was developed into dedicated versions for iOS and Android . Initially, I wanted to create an AI to play the game and figure out how many percents the AI can win the game. So, I started to learn JavaScript and design algorithm for the AI. To do this, naturally I came across Github , the Git repository web-based hosting server. Then, I learned about Git , the distributed version control system. And the book, Pro Git , helped me much to understand some difficult concepts. Now, I have created my own Github account , and I am still working on the AI project for 2048 . 4. Github Pages and Jekyll As what you are seeing now, my blog is powered by Github Pages and Jekyll . Github Pages make it very easy to create a website hosted directly from Github repository. By Registration and just a few steps, you can publish you own site. Thanks for the powerful host server of Github, the accessibility is much better than free web host. And Jekyll is a powerful tool to transform plan texts into static websites and blogs. That is to say, by Jekyll, one can maintain a substantial website with little effort. Jekyll is running based on Ruby , so before installation of Jekyll, you should first setup Ruby. Things to Be done 1. Learn Advanced Algorithms. There is one blog (in Chinese) I found interesting about studying Algorithms, 我的算法学习之路 . 2. Learn 18.085 Computational Science and Engineering This course is given by Profess Gilbert Strang , and provides a review of linear algebra, including applications to networks, structures, and estimation, Lagrange multipliers. Also covered are: differential equations of equilibrium; Laplace's equation and potential flow; boundary-value problems; minimum principles and calculus of variations; Fourier series; discrete Fourier transform; convolution; and applications. 3. Learn Econometrics Get prepared for my next semester course. 4. K.O. GRE and IELTS/TOEFL Everyone desiring to go to graduate school knows what does it mean. 5. Work on My 2048 AI Project. Challenging! 6. Design a Website For the Company of My Mother Hope it will help the business of my mother. 7. One week a Blog I believe I can keep my passion. "},{"title":"Binary Search Time Complexity: Average Number of Comparisons","baseurl":"","url":"/blog/Binary%20Search.html","date":"2014-11-25 00:00:00 +0800","categories":["blog"],"body":"Introduction to Binary Search Binary search is a classic and basic search algorithm which is applicable when the array is ordered. This method using the the divide and conquer approach takes advantage of the information of the order of the elements and tries to do less work. Undoubtedly, binary search is very efficient. Java Code Implementation int binarySearch (int [ ] E, int first, int last, int k) { if (last < first return -1; else { int mid = (first + last) / 2; if (k == E[mid]) return mid; else if (k < E[mid]) return binarySearch (E, first, mid − 1, k); else return binarySearch (E, mid + 1, last, k); } } Time Complexity Analysis 1. Worst-case The implementation of binary search is a recursive function, so recursive equation should be established for time complexity analysis. Look back to the code, if we assume the total time of binary search is $T(n)$, for each recursive invocation, the time is $T({n \\over 2})$. So it is not difficult to find the recursive equation. $$T(n)=T({n\\over 2})+c$$ Assume $n=2^k$, $$T(n)=T({n\\over 4})+2c=T({n\\over 8})+3c=...=T({n\\over 2^k})+kc=T(1)+kc$$. Notice that $k=log_2(n)$ and $T(1)=c$, so $T(n)=(k+1)c=(log_2(n)+1)c=O(log(n))$. 2. Average-case Assume $ q $ is the probability that a search is successful and $ n=2^k-1 $. If $A_s(n)$ is the average number of comparisons that a successful search and $A_f(n)$ is the number of comparisons in an unsuccessful search. Then by the law of expectation, $$A_q(n)=qA_s(n)+(1-q)A_f(n).$$ Next, we should calculate $A_s(n)$ and $A_f(n)$ respectively. For $A_f(n)$, we can use the result of the worst-case analysis, because for unsuccessful search we have to conduct the search until last < first .That is to say, the average case for unsuccessful search is $\\lfloor log_2(n) \\rfloor +1=log_2(n+1)$, taking $c=1$. For $As(n)$, the thing is a little bit more complex. We have to find the number of comparisons for every possible case. It is easy to see that if the key is at the position of $n \\over 2$, only 1 comparison is necessary to find the key. Also if the key is at the position of $n\\over4$ or $3n \\over 4$, with 2 comparisons we can find the key. And so on, if the key is located at $(2i-1){n \\over 2^m}$ for $i=1,2...2^{m-1}$, m comparisons are needed. For all the cases, the sum of the elements $1+2+3+...+2^{m-1}$ should be $n$. That is to say, ${1+2+4+...+2^{m-1}}={(1-2^{m})\\over 1-2}=2^{m}-1=n=2^k-1$. So $$m=k.$$ Assume the possibility of all the cases is equal to $1\\over n$, so the average number of comparisons in successful binary search is $$\\sum_{i=1}^{k}{1\\over n}*i*2^{i-1}.$$ By the formula $$\\sum_{i=1}^{k}i*2^{i-1}=2^kk-2^k+1,$$ we can get that $$A_s(n)=log_2(n+1)+{log_2(n+1)\\over n} -1.$$ So after all, $$A_q(n)=q{log_2(n+1) \\over n}-q+log_2(n+1).$$ Through the analysis, we can draw the conclusion that the average case of binary search is $qO({log(n) \\over n})-q+O(log(n)).$ "},{"title":"Integration of Mergesort and Insertion Sort","baseurl":"","url":"/blog/Integration%20of%20Mergesort%20and%20Insertion%20Sort.html","date":"2014-11-28 00:00:00 +0800","categories":["blog"],"body":"Introduction to Mergesort and Insertion Sort Insertion Sort Insertion sort is a intuitive, primitive sorting method. Given a Given an unordered set of objects, the algorithm repeatedly removes an entry from the set and insert it into a new ordered list. void InsertionSort(ALIST slot[ ], int n) { // input slot is an array of n records; // assume n > 1; for (int i=1; i < n; i++) { for (int j=i; j > 0; j--) { if (slot[j].key < slot[j-1].key) swap(slot[j], slot[j-1]); else break; } } } The time complexity of insertion sort is in the order of $n^2$ . Since sorting is performed directly on original array without any working storage, swapping and shifting which are time consuming are essential. So insertion sort is slow when a large size of array is going to be sorted. While for small-size arrays, insertion sort is still a simple and reliable algorithm. Mergesort Mergesort is a useful sorting algorithm based on the idea of divide-and-conquer . For each iteration, the unsorted array is divided into two sub-arrays, and they are separately sorted. Then the two sorted sub-arrays merge together. void mergesort(int n, int m) { int mid = (n+m)/2; if (m-n <= 0) return; else if (m-n > 1) { mergesort(n, mid); mergesort(mid+1, m); } merge(n, m); } The key point of mergesort is how merge() merges two sub-arrays of elements between index n and mid, and between mid+1 and m. void merge(int n, int m) { if (m-n <= 0) return; divide the list into 2 halves; // both halves are sorted while (both halves are not empty) { compare the 1 st elements of the 2 halves; // 1 comparison if (1 st element of 1st half is smaller) 1 st element of 1st half joins the end of the merged list; else if (1 st element of 2nd half is smaller) move the 1 st element of 2nd half to the end of the merged list; else { // the 1 st elements of the 2 halves are equal if (they are the last elements) break; 1 st element of 1st half joins end of the merged list; move the 1 st element of 2nd half to the end of the merged list; } } // end of while loop; } // end of merge The time complexity of mergesort is in the order of $nlog(n)$ . But when the size of the array to be sorted is small, the the overhead of many recursive calls will make the algorithm inefficient. Integration of Mergesort and Insertion Sort Modified Mergesort In oder to overcome the disadvantages of both mergesort and insertion sort, we can develop modified mergesort on the basis of integration of mergesort and insertion sort. This new algorithm can be achieved by choosing a small value of fac as a threshold for the size of sub-arrays. When the size of a sub-array in a recursive call is less than or equal to the value of fac , the algorithm will switch to insertion sort, which is efficient for small input. A pseudocode of the modified mergesort is given below: void mergeSort(Element E[], int first, int last, int fac) { if (last – first > S) { int mid = (first + last)/2; mergeSort(E, first, mid, S); mergeSort(E, mid + 1, last, S); merge(E, first, mid, last); } else { insertionSort(E, first, last); } } Implement of Modified Mergesort Array.java A class which consists of constructors, and methods such as InsertionSort( ), Merge( ), MergeSort( ), Sort( ) (which uses InsertionSort( ) to sort the sub-arrays with size < factor). The number of comparisons are returned using the GetCounter( ) method, and the randomly generated data of array are returned using GetArray( ) method. public class Array{ //Array Class private int n; //Class member size of Array private int [] S; //Class member data of Array private long counter; //Class member count comparisons private int factor; public Array(){ //Default constructor n = 0; S = new int [n]; counter = 0; factor = 0; } public Array(int size){ //Constructor with Initialization n = size; if(n <= 0) System.err.println(\"The input Array size is incorrect.\"); else{ S = new int [n]; Random ran = new Random(); for(int i = 0; i < n; i++){ S[i] = Math.abs(ran.nextInt()); //Set random data to Array } } counter = 0; factor = 10; } public Array(int size, int fac){ //Constructor with Initialization n = size; if(n <= 0) System.err.println(\"The input Array size is incorrect.\"); else{ S = new int [n]; Random ran = new Random(); for(int i = 0; i < n; i++){ S[i] = Math.abs(ran.nextInt()); //Set random data to Array } } counter = 0; factor = fac; } public Array(Array aArray){ //Copy constructor this.n = aArray.n; this.counter = aArray.counter; this.factor = aArray.factor; S = new int[aArray.n]; for(int i = 0; i < aArray.n; i++){ this.S[i] = aArray.S[i]; } } public void InsertionSort(int start, int last){ //Class methods for (int i = start; i <= last; i++){ for (int j = i; j > start; j--) { if (S[j] < S[j-1]){ counter++; int tmp = S[j]; S[j] = S[j-1]; S[j-1] = tmp; } else break; } } } private void Merge(int start, int end){ //Class methods, used in MergeSort int mid = (start + end) / 2; int a = start, b = mid + 1, index = 0; int[] tmpArray = new int[end - start + 1]; while(a <= mid && b <= end){ if(S[a] <= S[b]){ tmpArray[index++] = S[a]; a++; } else{ tmpArray[index++] = S[b]; b++; } counter++; } while(a <= mid){ tmpArray[index++] = S[a++]; } while(b <= end){ tmpArray[index++] = S[b++]; } for(int i = start; i <= end; i++){ S[i] = tmpArray[i - start]; } } public void MergeSort(int start, int end){ //Class methods MergeSort if(end - start <= 0) return; else if(end - start > 1){ int mid=(start+end)/2; MergeSort(start,mid); MergeSort(mid+1,end); } Merge(start,end); } public void Sort(int first, int last){ //Class methods Sort if(last - first > factor){ int mid = (first + last)/ 2; Sort(first, mid); Sort(mid + 1, last); Merge(first, last); } else{ InsertionSort(first, last); } } public long GetCounter(){ //Class methods, get number of comparisons return(counter); } public int[] GetArray(){ //Class methods, get data of Array int[] tmp = new int[n]; for(int i = 0; i < n; i++){ tmp[i] = S[i]; } return(tmp); } } Experiment on Modified Mergesort I did series of experiments to explore how modified mergesort improves on the basis of mergesort by generating input data sets of various sizes, randomly ranging from 1,000 to 1,000,000 integers to see the number of key comparisons and CPU times taken by modified mergesort compared with origin mergesort. And I also studied how how the different values of S would affect the performance of the modified algorithm. 1. Compare the number of key comparisons taken by modified mergesort and origin mergesort Figure 1: Curve of Modified Mergesort Key Comparisons vs. Array Size From Figure 1, we can obtain the relationship between the number of key comparisons and array size in modified mergesort. By curve fitting tool of Matlab, we find that the relationship function is mostly like $nlog(n)$. Figure 2: Curve of Mergesort Key Comparisons vs. Array Size From Figure 2, we can obtain the relationship between the number of key comparisons and array size in mergesort. By curve fitting tool of Matlab, we find that the relationship function is mostly like $nlog(n)$. Through analysis, the relationship between key comparisons and array size in modified mergesort is $nlog(n)$. Although it is the same in Merge Sort, when compare the exact number of key comparisons with same array size in Advanced Merge Sort and Merge Sort, Advanced Merge Sort conducts fewer comparisons. By curve fitting, we obtain the mathematical relationship function between key comparisons and array size is $f(n) = 1.333nlog(n)$. 1. Compare the CPU time taken by modified mergesort and origin mergesort Figure 3: Curve of Modified Mergesort Time vs. Array Size From Figure 3, we can obtain the relationship between CPU time and array size in modified mergesort. By curve fitting tool of Matlab, we find that the relationship function is mostly like $n$. Figure 4: Curve of Mergesort Time vs. Array Size From Figure 4, we can obtain the relationship between CPU time and array size in mergesort. By curve fitting tool of Matlab, we find that the relationship function is mostly like $n$. Through analysis, the relationship between key comparisons and array size in modified mergesort is $n^2$ . Although it is the same as mergesort, when comparing the exact number of key comparisons with same array size in modified mergesort and mergesort, modified mergesort conducts fewer comparisons. By curve fitting, we obtain the mathematical relationship function between CPU time and array size is $f(t) = 0.0001928*t + -5.342$. 2. Number of key comparisons and CPU time taken by Advanced Merge Sort on the data sets with different factors Table 1: CPU Time and Key Comparisons of Modified Mergesort with Different Factor (ArraySize = 10000) Figure 5: Curve of Modified Mergesort Key Comparisons vs. Factor (ArraySize = 10000) From Figure 5, we can obtain the relationship between key comparisons and factor in modified mergesort. With factor increasing, we find it is difficult to gain the exact relationship function and the relationship is mostly like random distribution. For this result, two points can be taken into consideration. One is that we initialize the same-size array with random integers for each time conducting modified mergesort, so if the factor does not effect the number of comparisons, the number of comparisons would range in a small section. The other is that the performance of CPU is usually unstable. The speed of CPU is sometimes fast but at other times slow, so if the factor does not effect the number of comparisons, the number of comparisons would also range in a small section. Figure 6: Curve of Modified Mergesort Time vs. Factor (ArraySize = 10000) From Figure 6, we can obtain the relationship between CPU time and factor in modified mergesort. With factor increasing, the CPU time dramatically deceases, but when factor increasing to 10, the CPU time stay in a small range. It is remarkable to find there is a huge difference between the relationship of key comparison number and factor and the relationship of CPU time and factor. We consider that although with different factors the number of comparisons is almost the same, the operation time may not be the same when the time of other operations such as swap and assignment is taken into consideration, due to the different procedure of mergesort and insertion Sort. Conclusions 1. The improvement of Modified MergeSort As for key comparisons, the improvement of the modified mergesort is $$ {1.35-1.333 \\over 1.35} = 0.0126 $$ , which is not very significant. But as for CPU time, the improvement of the modified mergesort is $$ {0.000245-0.0001928 \\over 0.000245} = 0.213 $$ , which is very impressive. 2. The effect of different values of factor From the results, the factor have little effect on the number of key comparison conducted in modified mergesort, but it does reduce the CPU time especially when the factor is over 10. "}]}